# 学习笔记

刷题第一遍第二遍要背下来,第三次以上在逐步理解,一定要过变数

做题时,特别是递归,一定要想到最小范围,不要一层一层得去思考



## **Queue分析**

**Queue： 基本上，一个队列就是一个先入先出（FIFO）的数据结构**

**Queue接口与List、Set同一级别，都是继承了Collection接口。LinkedList实现了Deque接 口。**

![1611503295211](C:\Users\71004\AppData\Local\Temp\1611503295211.png)  

方法:

![1611503402405](C:\Users\71004\AppData\Local\Temp\1611503402405.png)

## PriorityQueue分析

队列是遵循先进先出（First-In-First-Out）模式的，但有时需要在队列中基于优先级处理对象。 

### 实现原理：

Java中PriorityQueue通过二叉小顶堆实现，可以用一棵完全二叉树表示（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为*PriorityQueue*的底层实现。

### 方法剖析:

#### add()和offer()

`add(E e)`和`offer(E e)`的语义相同，都是向优先队列中插入元素，只是`Queue`接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回`false`。对于*PriorityQueue*这两个方法其实没什么差别。

#### element()和peek()

`element()`和`peek()`的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回`null`。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，`0`下标处的那个元素既是堆顶元素。所以**直接返回数组0下标处的那个元素即可**。

#### remove()和poll()

`remove()`和`poll()`方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回`null`。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。

## HashMap分析

见xmind文档

